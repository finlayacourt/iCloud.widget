// -----------------------------------
//  OPTIONS
    	
   	const chartWidth = 400
   	const hoursTillRefresh = 24
   	const position = 'bottom right'

// -----------------------------------

import { styled } from "uebersicht"

// Load auth token generated by setup
import auth from "./auth.json"

export const refreshFrequency = 1000*60*60*hoursTillRefresh

export const command = dispatch => {
	// Request storage info from icloud using auth token
	const encoded = btoa(`${auth.appleAccountInfo.dsid}:${auth.tokens.mmeAuthToken}`)
	const url = `http://127.0.0.1:41417/https://p21-quota.icloud.com/quotaservice/external/osx/${auth.appleAccountInfo.dsid}/storageUsageInfo`
	fetch(url, {
		headers: {
			"Authorization": `Basic ${encoded}`,
			"Content-Type": "application/json"
		}
	})
	.then(r => r.json())
	.then(r => dispatch({ type: 'FETCH_SUCCEDED', data: r }))
	.catch(e => dispatch({ type: 'FETCH_FAILED', error: e }))
}

export const initialState = []

export const updateState = ({type, data}, state) => {
	// Convert bytes to readble format
	const formatFileSize = bytes => {
		const i = Math.floor( Math.log(bytes) / Math.log(1024) )
		return ( bytes / Math.pow(1024, i) ).toFixed(2) * 1 + ' ' + ['B', 'kB', 'MB', 'GB', 'TB'][i]
	}

	switch (type) {
		case 'FETCH_SUCCEDED':
			const media = data.storageUsageByMedia
			const info = data.storageUsageInfo

			return media
			.map(item => ({
				proportion: item.usageInBytes/info.totalStorageInBytes,
				background: item.displayColor,
				content: item.displayLabel
			}))
			.concat({
				proportion: (info.totalStorageInBytes - info.usedStorageInBytes)/info.totalStorageInBytes,
				background: "fff",
				content: formatFileSize(info.totalStorageInBytes - info.usedStorageInBytes)
			})
		default:
			return state
	}
}

// Choose text color for best contract with background
const textColor = backgroundColor => {
	var r = parseInt(backgroundColor.substr(0,2),16);
	var g = parseInt(backgroundColor.substr(2,2),16);
	var b = parseInt(backgroundColor.substr(4,2),16);
	var yiq = ((r*299)+(g*587)+(b*114))/1000;
	return (yiq >= 128) ? '#000' : '#fff';
}

// Test if text will fit into textbox of certain width
const doesTextFit = (text, width) => {
	const canvas = document.createElement('canvas')
	const context = canvas.getContext('2d')
	context.font = '13px sans-serif'
	const metrics = context.measureText(text)
	return metrics.width < width
}

const Chart = styled("div")(props => ({
	width: `${props.width}px`,
	height: "30px",
	lineHeight: "30px",
	borderRadius: "5px",
	border: "1px solid #ccc",
	boxShadow: "0px 0px 2px #ccc",
	background: "#fff"
}))

const Item = styled("div")(props => ({
	width: `${props.width}px`,
	height: "100%",
	left: `${props.width}px`,
	float: "left",
	textAlign: "center",
	background: `#${props.background}`,
	color: (props.fits) ? textColor(props.background) : "transparent"
}))

export const className = `
	-webkit-font-smoothing: antialiased;
	font-family: -apple-system;
	font-weight: 300;
	font-size: 13px;
	line-height: 1.2;
	text-rendering: optimizeLegibility;
	position: absolute;
	${position.split(' ')[0]}: 20px;
	${position.split(' ')[1]}: 20px;
`

export const render = content => {
	let offset = 0
	return (
		<Chart width={chartWidth}>
			{content.map((item,index) => {
				const width = item.proportion*chartWidth
				offset += width
				return (
					<Item width={width.toFixed(2)} left={width.toFixed(2)} background={item.background} fits={doesTextFit(item.content, width)} key={index}>
						{item.content}
					</Item>
				)
			})}
		</Chart>
	)
}